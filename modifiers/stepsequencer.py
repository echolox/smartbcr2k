from .modifier import Modifier
from util.attribute_mapping import AttributeType, AttributeDescriptor, AttributeGapSpan

class StepSequencer(Modifier):

    steps = [AttributeDescriptor("step_%i" % i, -1.0, 1.0, float, AttributeType.span, False, None) for i in range(16)]

    attribute_configs = (
        # First control is always the current value display
        AttributeDescriptor("frequency", 0.01,  10, float, AttributeType.span, False, 100),
        AttributeDescriptor("amplitude",    0, 127, int,   AttributeType.span, False, None),
        AttributeDescriptor("offset",    -0.5, 0.5, float, AttributeType.span, False, None),
        AttributeDescriptor("length",       1,  16, int,   AttributeType.span, False, None),
        AttributeGapSpan,
        AttributeGapSpan,
        AttributeGapSpan,

        *steps,
    )

    MAX_STEPS = 16

    def __init__(self, name, frequency=0.25, length=MAX_STEPS, **kwargs):
        super().__init__(name, **kwargs)
        self.frequency = frequency
        self.offset = 0.0
        self.length = 7
        self.steps = [0.0] * StepSequencer.MAX_STEPS

        self.cursor = 0.0
        self.last_t = None

    @staticmethod
    def step_from_attr(attr):
        return int(attr.split("_")[1])

    def __getattr__(self, attr):
        if attr.startswith("step_"):
            return self.steps[self.step_from_attr(attr)]
        else:
            return super().__getattribute__(attr)

    def __setattr__(self, attr, v):
        if attr.startswith("step_"):
            self.steps[self.step_from_attr(attr)] = v
        else:
            super().__setattr__(attr, v)

    def serialize(self):
        """
        Serializes Modifier attributes into a dictionary 
        :return: dict to recreate the object in its current state
        """
        m = super().serialize()
        m["frequency"] = self.frequency
        m["length"] = self.length
        m["offset"] = self.offset
        return m

    def from_dict(self, m, *args, **kwargs):
        """
        Recreates the state of the object from a dictionary generated by serialize
        :param m: the dictionary
        :param args: see parent class
        :param kwargs: see parent class
        """
        super().from_dict(m, *args, **kwargs)
        self.frequency = m["frequency"]
        self.length = m["length"]
        self.offset = m["offset"]

    def save(self):
        d = super().save()
        d["frequency"] = self.frequency
        d["length"] = self.length
        d["offset"] = self.offset
        return d

    def load(self, d, i):
        super().load(d, i)
        self.frequency = d["frequency"]
        self.length = d["length"]
        self.offset = d["offset"]

    def calculate(self, time_report):
        # TODO: Sync to midi clock
#        t *= self.frequency
        t = time_report.prog

        if self.last_t is None:
            self.cursor = t
        else:
            self.cursor += t - self.last_t

        self.last_t = t

        self.cursor = (self.cursor + self.offset) % 1

        return self.steps[int(self.cursor * 16)]
